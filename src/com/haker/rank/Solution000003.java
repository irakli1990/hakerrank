package com.haker.rank;

import java.util.ArrayList;
import java.util.*;

import java.util.Scanner;

//Note: In this problem you must NOT generate any output on your own. Any such solution will be considered as being against the rules and its author will be disqualified. The output of your solution must be generated by the uneditable code provided for you in the solution template.
//
//        An important concept in Object-Oriented Programming is the open/closed principle, which means writing code that is open to extension but closed to modification. In other words, new functionality should be added by writing an extension for the existing code rather than modifying it and potentially breaking other code that uses it. This challenge simulates a real-life problem where the open/closed principle can and should be applied.
//
//        A Tree class implementing a rooted tree is provided in the editor. It has the following publicly available methods:
//
//        getValue(): Returns the value stored in the node.
//        getColor(): Returns the color of the node.
//        getDepth(): Returns the depth of the node. Recall that the depth of a node is the number of edges between the node and the tree's root, so the tree's root has depth  and each descendant node's depth is equal to the depth of its parent node .
//        In this challenge, we treat the internal implementation of the tree as being closed to modification, so we cannot directly modify it; however, as with real-world situations, the implementation is written in such a way that it allows external classes to extend and build upon its functionality. More specifically, it allows objects of the TreeVis class (a Visitor Design Pattern) to visit the tree and traverse the tree structure via the accept method.
//
//        There are two parts to this challenge.

enum Color {
    RED, GREEN
}

abstract class Tree {

    private int value;
    private Color color;
    private int depth;

    public Tree(int value, Color color, int depth) {
        this.value = value;
        this.color = color;
        this.depth = depth;
    }

    public int getValue() {
        return value;
    }

    public Color getColor() {
        return color;
    }

    public int getDepth() {
        return depth;
    }

    public abstract void accept(TreeVis visitor);
}

class TreeNode extends Tree {

    private ArrayList<Tree> children = new ArrayList<>();

    public TreeNode(int value, Color color, int depth) {
        super(value, color, depth);
    }

    public void accept(TreeVis visitor) {
        visitor.visitNode(this);

        for (Tree child : children) {
            child.accept(visitor);
        }
    }

    public void addChild(Tree child) {
        children.add(child);
    }
}

class TreeLeaf extends Tree {

    public TreeLeaf(int value, Color color, int depth) {
        super(value, color, depth);
    }

    public void accept(TreeVis visitor) {
        visitor.visitLeaf(this);
    }
}

abstract class TreeVis {
    public abstract int getResult();

    public abstract void visitNode(TreeNode node);

    public abstract void visitLeaf(TreeLeaf leaf);

}

class SumInLeavesVisitor extends TreeVis {
    public int getResult() {

        return 0;
    }

    public void visitNode(TreeNode node) {
        //implement this
    }

    public void visitLeaf(TreeLeaf leaf) {
        //implement this
    }
}

class ProductOfRedNodesVisitor extends TreeVis {
    public int getResult() {
        //implement this
        return 1;
    }

    public void visitNode(TreeNode node) {
        //implement this
    }

    public void visitLeaf(TreeLeaf leaf) {
        //implement this
    }
}

class FancyVisitor extends TreeVis {
    public int getResult() {
        //implement this
        return 0;
    }

    public void visitNode(TreeNode node) {
        //implement this
    }

    public void visitLeaf(TreeLeaf leaf) {
        //implement this
    }
}

public class Solution000003 {
    private static final Scanner scanner = new Scanner(System.in);

    static int n;
    static int nSequence;
    static int[] treeSequence;
    static byte[] colorSequence;
    static int[][] treeOrder;


    public static Tree solve() {
        System.out.println("Enter n:");
        n = scanner.nextInt();
        nSequence = n - 1;
        treeSequence = new int[n];
        colorSequence = new byte[n];
        treeOrder = new int[nSequence][2];
        System.out.println("Enter tree sequence");
        for (int i = 0; i < treeSequence.length; i++) {
            treeSequence[i] = scanner.nextInt();
        }
        System.out.println("Enter tree sequence 0 or 1 only");
        for (int i = 0; i < colorSequence.length; i++) {
            byte input = scanner.nextByte();
            colorSequence[i] = input;
        }
        System.out.println("Enter tree order");
        for (int i = 0; i < treeOrder.length; i++) {
            for (int j = 0; j < treeOrder.length; j++) {
                treeOrder[i][j] = scanner.nextInt();
            }
        }
        Arrays.toString(colorSequence);
        Arrays.toString(treeSequence);
        Arrays.toString(treeOrder);
        return null;
    }


    public static void main(String[] args) {
        Tree root = solve();
        SumInLeavesVisitor vis1 = new SumInLeavesVisitor();
        ProductOfRedNodesVisitor vis2 = new ProductOfRedNodesVisitor();
        FancyVisitor vis3 = new FancyVisitor();

        root.accept(vis1);
        root.accept(vis2);
        root.accept(vis3);

        int res1 = vis1.getResult();
        int res2 = vis2.getResult();
        int res3 = vis3.getResult();

        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
    }
}
